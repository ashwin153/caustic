package caustic.compiler

import caustic.compiler.types.Universe
import caustic.compiler.visitors.Generate
import caustic.grammar.{CausticLexer, CausticParser}

import org.antlr.v4.runtime.{CharStreams, CommonTokenStream}
import java.io.{File, FileOutputStream}
import java.nio.file.{Files, Path, Paths}

import scala.util.Try
import scala.collection.JavaConverters._
import scala.collection.mutable

/**
 * A compiler for the Caustic programming language.
 */
object Compiler {

  /**
   *
   * @param args
   */
  def main(args: Array[String]): Unit = {
    // Print usage information.
    if (args.length < 1 || args.length > 2) {
      println("Usage: caustic <source> [config]")
      System.exit(1)
    }

    // Run the compiler on all the specified files.
    Files.walk(Paths.get(args(0))) forEach { path =>
      if (path.toString.endsWith(".acid")) Compiler.execute(path).get
    }
  }

  /**
   * Compiles the specified source file, and returns the generated [[Universe]].
   *
   * @param parser  ANTLR [[org.antlr.v4.runtime.Parser]].
   * @param handler Compiler [[Handler]].
   * @return Generated [[Universe]].
   */
  def execute(parser: CausticParser, handler: Handler): Try[Universe] = Try {
    // Construct a generator for the file.
    val program = parser.program()
    val namespace = program.module().Identifier().asScala.map(_.getText)
    val filename = handler.source.getFileName.toString.split("\\.")(0)
    val gen = Generate(handler, Universe.root.child(namespace: _*))

    val output =
      s"""// Autogenerated by Caustic Compiler
         |package ${ namespace mkString "." }
         |
         |import caustic.runtime._
         |import spray.json._
         |import DefaultJsonProtocol._
         |import scala.util.Try
         |
         |${ program.include().asScala.map(gen.visitInclude) mkString "\n" }
         |
         |object ${ namespace mkString "$" }$$$filename$$Implicits {
         |  type Pointer[+T] = String
         |}
         |
         |import ${ namespace mkString "$" }$$$filename$$Implicits._
         |
         |${ program.declaration().asScala.map(gen.visitDeclaration) mkString "\n" }
       """.stripMargin

    // Write the generated sources to file.
    val file = new File(parser.getSourceName.replaceFirst(".acid$", "") + ".scala")
    val writer = new FileOutputStream(file)
    writer.write(output.getBytes("UTF-8"))
    writer.close()

    // Return the generated universe.
    gen.universe
  }

  /**
   * Compiles the specified source file, and returns the generated [[Universe]]. Compilation is
   * memoized (https://stackoverflow.com/a/36960228/1447029); therefore, the same path will never be
   * recompiled twice, even if it is imported in multiple different files. Incremental compilation
   * can be implemented by persisting the [[Map]] across compiler invocations.
   */
  lazy val execute: Path => Try[Universe] = new mutable.HashMap[Path, Try[Universe]]() {
    override def apply(path: Path): Try[Universe] = getOrElseUpdate(path, {
      // Resolve the path into an absolute path.
      val source = if (path.isAbsolute) path else Paths.get("").toAbsolutePath.resolve(path)

      // Lex and parse the program.
      val lexer = new CausticLexer(CharStreams.fromPath(source))
      val tokens = new CommonTokenStream(lexer)
      val parser = new CausticParser(tokens)

      // Utilize the customized error handler mechanism.
      val handler = Handler(source)
      parser.removeErrorListeners()
      parser.addErrorListener(handler)

      // Execute the goal, but fail if any errors are detected.
      execute(parser, handler).filter(_ => handler.errors == 0)
    })
  }

}