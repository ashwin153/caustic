package caustic.compiler.types

import scala.collection.mutable

/**
 * A lexically-scoped [[Symbol]] table. Universes maintain a mapping that uniquely associates a
 * name to a [[Symbol]]. Each [[Symbol]] is assigned a globally unique identifier when it is added
 * to the Universe, that is generated by concatenating the local name of the [[Symbol]] with the
 * current lexical scope of the Universe and the type of the [[Symbol]]. Therefore, no two
 * [[Symbol]] entries of the same type may exist in the same scope at the same time. Universes may
 * spawn children that inherit the symbols of the parent Universe; however, modifications to the
 * child Universe may temporarily hide but cannot overwrite symbols in the parent Universe.
 *
 * @param variables [[Variable]] symbol table.
 * @param functions [[Function]] symbol table.
 * @param services [[Service]] symbol table.
 * @param aliases [[Alias]] symbol table.
 * @param labels Scope labels.
 */
case class Universe private(
  variables: mutable.Map[String, Variable] = mutable.Map.empty,
  functions: mutable.Map[String, Function] = mutable.Map.empty,
  services: mutable.Map[String, Service] = mutable.Map.empty,
  aliases: mutable.Map[String, Alias] = mutable.Map.empty,
  labels: List[String] = List.empty
) {

  // Monotonically increasing label counter.
  private var label: Int = -1

  /**
   * Returns the lexical scope of the Universe.
   *
   * @return Lexical scope.
   */
  def scope: String =
    this.labels.mkString("/")

  /**
   * Returns a mangled version of the name within the current scope.
   *
   * @return Mangled name.
   */
  def mangle(name: String): String =
    this.scope + "@" + name

  /**
   * Returns the Universe that created this Universe, or None if no such parent exists.
   *
   * @return Parent [[Universe]].
   */
  def parent: Option[Universe] =
    if (this.labels.isEmpty) None else Some(this.copy(labels = this.labels.dropRight(1)))

  /**
   * Returns a child Universe that inherits all existing symbols from this Universe. Modifications
   * to the child Universe may temporarily hide but cannot overwrite symbols in this Universe.
   *
   * @param module Unique names.
   * @return Child Universe.
   */
  def child(module: String*): Universe =
    if (module.isEmpty) {
      // If no module is specified, then assign a monotonically increasing label.
      this.label += 1
      this.copy(labels = this.labels :+ this.label.toString)
    } else {
      // Otherwise, use the provided module nam.
      this.copy(labels = this.labels ++ module)
    }

  /**
   * Returns the Variable with the corresponding name.
   *
   * @param name Name.
   * @return Corresponding [[Variable]].
   */
  def getVariable(name: String): Option[Variable] =
    this.variables.get(mangle(name)).orElse(this.parent.flatMap(_.getVariable(name)))

  /**
   * Constructs a [[Variable]] and adds it to the Universe.
   *
   * @param name Name.
   * @param datatype Underlying [[Type]].
   */
  def putVariable(name: String, datatype: Type): Unit =
    this.variables += mangle(name) -> Variable(name, mangle(name), datatype)

  /**
   * Returns the [[Function]] with the specified name.
   *
   * @param name Name.
   * @return Corresponding [[Function]].
   */
  def getFunction(name: String): Option[Function] =
    this.functions.get(mangle(name)).orElse(this.parent.flatMap(_.getFunction(name)))

  /**
   * Constructs a [[Function]] and adds it to the Universe.
   *
   * @param name Name.
   * @param args Arguments.
   * @param returns Return type.
   * @param body Function builder.
   */
  def putFunction(name: String, args: Map[String, Alias], returns: Alias)(body: Universe => Result): Unit = {
    // Add all arguments as variables to the function's universe.
    val context = this.child(name)
    args.toSeq foreach { case (n, t) => context.putVariable(n, t.datatype) }

    // Evaluate the body of the function and add it to the universe.
    val params = args.toSeq map { case (n, t) => Argument(n, s"""text("${ context.mangle(n) }")""", t) }
    this.functions += mangle(name) -> Function(name, params, returns, body(context))
  }

  /**
   * Returns the [[Alias]] with the corresponding name.
   *
   * @param name Name.
   * @return Corresponding [[Alias]].
   */
  def getAlias(name: String): Option[Alias] =
    this.aliases.get(mangle(name)).orElse(this.parent.flatMap(_.getAlias(name)))

  /**
   * Constructs an [[Alias]] to the [[Simple]] type and adds it to the Universe. Automatically
   * generates an [[Alias]] for pointers to the type, and a [[Function]] to construct instances of
   * and pointers to the [[Alias]].
   *
   * @param name Name.
   * @param simple [[Simple]] type.
   */
  def putAlias(name: String, simple: Simple): Unit = {
    // Construct a alias to the type, and to pointers of the type.
    val typ = Alias(name, simple)
    val ptr = Alias(name, Pointer(simple))

    // Add type aliases to the universe.
    this.aliases += mangle(name) -> typ
    this.aliases += mangle(name + "&") -> ptr

    // Add a constructor for pointers to the alias.
    putFunction(name + "&",  Map("key" -> getAlias("String").get), ptr) { func =>
      Result(Pointer(simple), s"""load("${ func.mangle("key") })")""")
    }

    simple match {
      case r: Record =>
        // Add a constructor for record aliases.
        putFunction(name, r.fields, typ) { func =>
          Result(r, s"""text("${ func.scope }")""")
        }
      case _ =>
    }
  }

  /**
   * Returns the [[Service]] with the corresponding name.
   *
   * @param name Name.
   * @return Corresponding [[Service]].
   */
  def getService(name: String): Option[Service] =
    this.services.get(mangle(name)).orElse(this.parent.flatMap(_.getService(name)))

  /**
   * Constructs a [[Service]] and adds it to the Universe.
   *
   * @param name Name.
   * @param service Service.
   */
  def putService(name: String, service: Service): Unit =
    this.services += mangle(name) -> service

}

object Universe {

  /**
   * Returns the root Universe. The root Universe is an ancestor of every Universe, and contains all
   * the built-in types that are included in every program. A Universe can only ever be created as a
   * child of the root Universe.
   *
   * @return Root Universe.
   */
  val root: Universe = {
    // Add built-in types to the universe.
    val base = Universe()
    base.putAlias("String", String)
    base.putAlias("Double", Double)
    base.putAlias("Int", Int)
    base.putAlias("Boolean", Boolean)
    base.putAlias("Unit", Null)

    // Return the root universe.
    base.child("root")
  }

}